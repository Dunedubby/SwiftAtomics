//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import *

  integerTypes = [
    # Swift        Storage                     ShimName
    ("Int8",       "_AtomicInt8Storage",       "Int8"),
    ("Int16",      "_AtomicInt16Storage",      "Int16"),
    ("Int32",      "_AtomicInt32Storage",      "Int32"),
    ("Int64",      "_AtomicInt64Storage",      "Int64"),
    ("UInt8",      "_AtomicInt8Storage",       "Int8"),
    ("UInt16",     "_AtomicInt16Storage",      "Int16"),
    ("UInt32",     "_AtomicInt32Storage",      "Int32"),
    ("UInt64",     "_AtomicInt64Storage",      "Int64"),
    ("Int",        "_AtomicIntStorage",        "Int"),
    ("UInt",       "_AtomicIntStorage",        "Int"),
    ("DoubleWord", "_AtomicDoubleWordStorage", "DoubleWord"),
  ]
}%
${autogenerated_warning()}

#if !ATOMICS_NATIVE_BUILTINS

#endif

% for (swiftType, storageType, shimType) in integerTypes:

extension ${swiftType}: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = ${swiftType}

    @usableFromInline
    internal typealias _Storage = ${storageType}

    @usableFromInline
    internal var _storage: _Storage

    @_transparent @_alwaysEmitIntoClient
    public init(_ value: Value) {
#if ATOMICS_NATIVE_BUILTINS
      _storage = Self._encode(value)
#else
      _storage = _sa_prepare_${shimType}(Self._encode(value))
#endif
    }

    @_transparent @_alwaysEmitIntoClient
    public func dispose() -> Value {
#if ATOMICS_NATIVE_BUILTINS
      return Self._decode(_storage)
#else
      return Self._decode(_sa_dispose_${shimType}(_storage))
#endif
    }
  }
}

extension UnsafeMutablePointer
where Pointee == ${swiftType}.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  internal var _extract: UnsafeMutablePointer<Pointee._Storage> {
    // `${swiftType}.AtomicRepresentation` is layout-compatible with
    // its only stored property.
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
}

#if ATOMICS_NATIVE_BUILTINS
extension ${swiftType}.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  static func _decode(_ storage: _Storage) -> Value {
    return Value(storage._value)
  }

  @_transparent @_alwaysEmitIntoClient
  static func _encode(_ value: Value) -> _Storage {
    return _Storage(value._value)
  }
}
#else
extension ${swiftType}.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  static func _decode(_ v: ${shimType}) -> Value {
% if swiftType == shimType:
    return v
% else:
    return Value(v._value)
% end
  }

  @_transparent @_alwaysEmitIntoClient
  static func _encode(_ value: Value) -> ${shimType} {
% if swiftType == shimType:
    return value
% else:
    return ${shimType}(value._value)
% end
  }
}
#endif

extension ${swiftType}.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: ${swiftType},
    desired: ${swiftType},
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: ${swiftType}) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}

% if swiftType != "DoubleWord":
extension ${swiftType}: AtomicInteger {}

extension ${swiftType}.AtomicRepresentation: AtomicIntegerStorage {
% for (name, cname, op, label, doc) in integerOperations:
% defaultValue = " = 1" if label != "" else ""
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  @discardableResult
  public static func atomicLoadThen${name}(
    ${label} operand: ${swiftType}${defaultValue},
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> ${swiftType} {
    let r = pointer._extract._atomicLoadThen${name}(
      ${argLabel(label)}Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }

% end
}

% end

%   end
% end
